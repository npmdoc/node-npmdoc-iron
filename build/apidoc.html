<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/hueniverse/iron#readme"

    >iron (v4.0.4)</a>
</h1>
<h4>Encapsulated tokens (encrypted and mac'ed objects)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.iron">module iron</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.decrypt">
            function <span class="apidocSignatureSpan">iron.</span>decrypt
            <span class="apidocSignatureSpan">(password, options, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.encrypt">
            function <span class="apidocSignatureSpan">iron.</span>encrypt
            <span class="apidocSignatureSpan">(password, options, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.generateKey">
            function <span class="apidocSignatureSpan">iron.</span>generateKey
            <span class="apidocSignatureSpan">(password, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.hmacWithPassword">
            function <span class="apidocSignatureSpan">iron.</span>hmacWithPassword
            <span class="apidocSignatureSpan">(password, options, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.seal">
            function <span class="apidocSignatureSpan">iron.</span>seal
            <span class="apidocSignatureSpan">(object, password, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.iron.unseal">
            function <span class="apidocSignatureSpan">iron.</span>unseal
            <span class="apidocSignatureSpan">(sealed, password, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">iron.</span>algorithms</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">iron.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">iron.</span>macFormatVersion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">iron.</span>macPrefix</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.iron" id="apidoc.module.iron">module iron</a></h1>


    <h2>
        <a href="#apidoc.element.iron.decrypt" id="apidoc.element.iron.decrypt">
        function <span class="apidocSignatureSpan">iron.</span>decrypt
        <span class="apidocSignatureSpan">(password, options, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (password, options, data, callback) {

    exports.generateKey(password, options, (err, key) =&#x3e; {

        if (err) {
            return callback(err);
        }

        const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
        let dec = decipher.update(data, null, &#x27;utf8&#x27;);
        dec = dec + decipher.final(&#x27;utf8&#x27;);

        callback(null, dec);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.iron.encrypt" id="apidoc.element.iron.encrypt">
        function <span class="apidocSignatureSpan">iron.</span>encrypt
        <span class="apidocSignatureSpan">(password, options, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (password, options, data, callback) {

    exports.generateKey(password, options, (err, key) =&#x3e; {

        if (err) {
            return callback(err);
        }

        const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
        const enc = Buffer.concat([cipher.update(data, &#x27;utf8&#x27;), cipher.final()]);

        callback(null, enc, key);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.iron.generateKey" id="apidoc.element.iron.generateKey">
        function <span class="apidocSignatureSpan">iron.</span>generateKey
        <span class="apidocSignatureSpan">(password, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateKey = function (password, options, callback) {

    const callbackTick = Hoek.nextTick(callback);

    if (!password) {
        return callbackTick(Boom.internal(&#x27;Empty password&#x27;));
    }

    if (!options ||
        typeof options !== &#x27;object&#x27;) {

        return callbackTick(Boom.internal(&#x27;Bad options&#x27;));
    }

    const algorithm = exports.algorithms[options.algorithm];
    if (!algorithm) {
        return callbackTick(Boom.internal(&#x27;Unknown algorithm: &#x27; + options.algorithm));
    }

    const generate = () =&#x3e; {

        if (Buffer.isBuffer(password)) {
            if (password.length &#x3c; algorithm.keyBits / 8) {
                return callbackTick(Boom.internal(&#x27;Key buffer (password) too small&#x27;));
            }

            const result = {
                key: password,
                salt: &#x27;&#x27;
            };

            return generateIv(result);
        }

        if (password.length &#x3c; options.minPasswordlength) {
            return callbackTick(Boom.internal(&#x27;Password string too short (min &#x27; + options.minPasswordlength + &#x27; characters required
)&#x27;));
        }

        if (options.salt) {
            return generateKey(options.salt);
        }

        if (options.saltBits) {
            return generateSalt();
        }

        return callbackTick(Boom.internal(&#x27;Missing salt or saltBits options&#x27;));
    };

    const generateSalt = () =&#x3e; {

        const randomSalt = Cryptiles.randomBits(options.saltBits);
        if (randomSalt instanceof Error) {
            return callbackTick(Boom.wrap(randomSalt));
        }

        const salt = randomSalt.toString(&#x27;hex&#x27;);
        return generateKey(salt);
    };

    const generateKey = (salt) =&#x3e; {

        Crypto.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, &#x27;sha1&#x27;, (err, derivedKey) =&#x3e; {

            if (err) {
                return callback(Boom.wrap(err));
            }

            const result = {
                key: derivedKey,
                salt
            };

            return generateIv(result);
        });
    };

    const generateIv = (result) =&#x3e; {

        if (algorithm.ivBits &#x26;&#x26;
            !options.iv) {

            const randomIv = Cryptiles.randomBits(algorithm.ivBits);
            if (randomIv instanceof Error) {
                return callbackTick(Boom.wrap(randomIv));
            }

            result.iv = randomIv;
            return callbackTick(null, result);
        }

        if (options.iv) {
            result.iv = options.iv;
        }

        return callbackTick(null, result);
    };

    generate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.iron.hmacWithPassword" id="apidoc.element.iron.hmacWithPassword">
        function <span class="apidocSignatureSpan">iron.</span>hmacWithPassword
        <span class="apidocSignatureSpan">(password, options, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hmacWithPassword = function (password, options, data, callback) {

    exports.generateKey(password, options, (err, key) =&#x3e; {

        if (err) {
            return callback(err);
        }

        const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
        const digest = hmac.digest(&#x27;base64&#x27;).replace(/\+/g, &#x27;-&#x27;).replace(/\//g, &#x27;_&#x27;).replace(/\=/g, &#x27;&#x27;);

        const result = {
            digest,
            salt: key.salt
        };

        return callback(null, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.iron.seal" id="apidoc.element.iron.seal">
        function <span class="apidocSignatureSpan">iron.</span>seal
        <span class="apidocSignatureSpan">(object, password, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seal = function (object, password, options, callback) {

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    const callbackTick = Hoek.nextTick(callback);

    // Serialize object

    const objectString = internals.stringify(object);
    if (objectString instanceof Error) {
        return callbackTick(objectString);
    }

    // Obtain password

    let passwordId = &#x27;&#x27;;
    password = internals.normalizePassword(password);
    if (password.id) {
        if (!/^\w+$/.test(password.id)) {
            return callbackTick(Boom.internal(&#x27;Invalid password id&#x27;));
        }

        passwordId = password.id;
    }

    // Encrypt object string

    exports.encrypt(password.encryption, options.encryption, objectString, (err, encrypted, key) =&#x3e; {

        if (err) {
            return callback(err);
        }

        // Base64url the encrypted value

        const encryptedB64 = Hoek.base64urlEncode(encrypted);
        const iv = Hoek.base64urlEncode(key.iv);
        const expiration = (options.ttl ? now + options.ttl : &#x27;&#x27;);
        const macBaseString = exports.macPrefix + &#x27;*&#x27; + passwordId + &#x27;*&#x27; + key.salt + &#x27;*&#x27; + iv + &#x27;*&#x27; + encryptedB64 + &#x27;*&#x27; + expiration
;

        // Mac the combined values

        exports.hmacWithPassword(password.integrity, options.integrity, macBaseString, (err, mac) =&#x3e; {

            if (err) {
                return callback(err);
            }

            // Put it all together

            // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
            // Allowed URI query name/value characters: *-. \d \w

            const sealed = macBaseString + &#x27;*&#x27; + mac.salt + &#x27;*&#x27; + mac.digest;
            return callback(null, sealed);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    d: {
        e: &#x27;f&#x27;
    }
};

var password = &#x27;some_not_random_password_that_is_at_least_32_characters&#x27;;

Iron.<span class="apidocCodeKeywordSpan">seal</span>(obj, password, Iron.defaults, function (err, sealed) {

    console.log(sealed);
});
```

The result `sealed` object is a string which can be sent via cookies, URI query parameter, or an HTTP header attribute.
To unseal the string:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.iron.unseal" id="apidoc.element.iron.unseal">
        function <span class="apidocSignatureSpan">iron.</span>unseal
        <span class="apidocSignatureSpan">(sealed, password, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unseal = function (sealed, password, options, callback) {

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    const callbackTick = Hoek.nextTick(callback);

    // Break string into components

    const parts = sealed.split(&#x27;*&#x27;);
    if (parts.length !== 8) {
        return callbackTick(Boom.internal(&#x27;Incorrect number of sealed components&#x27;));
    }

    const macPrefix = parts[0];
    const passwordId = parts[1];
    const encryptionSalt = parts[2];
    const encryptionIv = parts[3];
    const encryptedB64 = parts[4];
    const expiration = parts[5];
    const hmacSalt = parts[6];
    const hmac = parts[7];
    const macBaseString = macPrefix + &#x27;*&#x27; + passwordId + &#x27;*&#x27; + encryptionSalt + &#x27;*&#x27; + encryptionIv + &#x27;*&#x27; + encryptedB64 + &#x27;*&#x27; +
expiration;

    // Check prefix

    if (macPrefix !== exports.macPrefix) {
        return callbackTick(Boom.internal(&#x27;Wrong mac prefix&#x27;));
    }

    // Check expiration

    if (expiration) {
        if (!expiration.match(/^\d+$/)) {
            return callbackTick(Boom.internal(&#x27;Invalid expiration&#x27;));
        }

        const exp = parseInt(expiration, 10);
        if (exp &#x3c;= (now - (options.timestampSkewSec * 1000))) {
            return callbackTick(Boom.internal(&#x27;Expired seal&#x27;));
        }
    }

    // Obtain password

    if (password instanceof Object &#x26;&#x26;
        !(Buffer.isBuffer(password))) {

        password = password[passwordId || &#x27;default&#x27;];
        if (!password) {
            return callbackTick(Boom.internal(&#x27;Cannot find password: &#x27; + passwordId));
        }
    }
    password = internals.normalizePassword(password);

    // Check hmac

    const macOptions = Hoek.clone(options.integrity);
    macOptions.salt = hmacSalt;
    exports.hmacWithPassword(password.integrity, macOptions, macBaseString, (err, mac) =&#x3e; {

        if (err) {
            return callback(err);
        }

        if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
            return callback(Boom.internal(&#x27;Bad hmac value&#x27;));
        }

        // Decrypt

        const encrypted = Hoek.base64urlDecode(encryptedB64, &#x27;buffer&#x27;);
        if (encrypted instanceof Error) {
            return callback(Boom.wrap(encrypted));
        }

        const decryptOptions = Hoek.clone(options.encryption);
        decryptOptions.salt = encryptionSalt;

        decryptOptions.iv = Hoek.base64urlDecode(encryptionIv, &#x27;buffer&#x27;);
        if (decryptOptions.iv instanceof Error) {
            return callback(Boom.wrap(decryptOptions.iv));
        }

        exports.decrypt(password.encryption, decryptOptions, encrypted, (ignoreErr, decrypted) =&#x3e; {         // Cannot fail since
 all errors covered by hmacWithPassword()

            // Parse JSON

            let object = null;
            try {
                object = JSON.parse(decrypted);
            }
            catch (err) {
                return callback(Boom.internal(&#x27;Failed parsing sealed object JSON: &#x27; + err.message));
            }

            return callback(null, object);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

The result `sealed` object is a string which can be sent via cookies, URI query parameter, or an HTTP header attribute.
To unseal the string:

```javascript
Iron.<span class="apidocCodeKeywordSpan">unseal</span>(sealed, password, Iron.defaults, function (err, unsealed) {

    // unsealed has the same content as obj
});
```

### Options
...</pre></li>
    </ul>










</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
